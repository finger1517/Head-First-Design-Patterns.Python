# Head First Design Patterns Python
## Chapter1 Strategy Pattern
策略模式定义了算法族,分别封装起来,让它们之间可以互相替换.此模式让算法的变化
独立于使用算法的客户

### target
class:
* MallardDuck
* RedheadDuck
* RubberDuck
* DecoyDuck

behaviour:
* fly
* quack

每种行为(fly)包括了一些具体行为(可以飞,不可以飞),将每种行为定义为算法族

## Chapter2 Observer Pattern
观察者模式,在对象之间定义一对多的依赖,这样一来,当一个对象改变状态,依赖它的对象
都会收到通知,并自动更新
### target
气象站,探测温度,湿度,气压,一旦三者发生变化,则传达给三个布告版,
布告版可以动态增加和删除


## 设计原则
* 多用组合少用继承
* 针对接口编程,不针对实现编程
* 为交互对象之间的松耦合设计而努力
* 对扩展开放,对修改关闭(装饰者模式)
* 要依赖抽象，不要依赖具体类（工厂模式）
    * 变量不可以具有具体类的引用
    * 不要让类派生自具体类
    * h不要覆盖基类中已实现的方法

## Chapter3 Decorator Pattern
### target
~~星巴克的咖啡~~ 因为喜欢喝奶茶所以换成奶茶店点奶茶吧

奶茶理应是一个对象,那么珍珠奶茶应该也是一个对象,珍珠奶茶加椰果也应该是一个对象,珍珠奶茶加双份珍珠加椰果再加奶盖也是一个对象,水果茶加椰果也是一个对象...

如何组织这些对象,并且正确算出奶茶的价格呢?

### 装饰者模式
动态地将责任附加到对象上,若要扩展功能,装饰者提供里比继承更有弹性的替代方案

## Chapter4 工厂模式
### target
批萨店,有很多种批萨我们需要根据顾客点的批萨进行批萨的制作(批萨对象的创建),
为此我们的代码中充斥了大量的if else来判断究竟应该创建哪一种批萨对象.随着批萨种类
的增加,if else判断语句越来越长
### 工厂方法模式
工厂方法模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个,工厂方法让类把实例化
推迟到子类
### 例子
比如luoruotian的init_model方法其实就是一个静态工厂(用函数作为工厂),用来创建不同的
模型对象,是一个简单工厂
### 简单工厂和工厂方法的区别
简单工厂把全部的对象创建在一处解决，而工厂方法则是创建一个框架让子类决定如何实现

### 抽象工厂模式
抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

工厂方法和抽象工厂都是将对象创建的过程封装起来，以便将代码从具体类解耦

## Chapter5 单件模式
## 单件模式
单件模式确保一个类只有一个实例,并提供一个全局访问点,比如线程池,日志对象等等...

## Chapter6 命令模式
将请求封装成对象,以便使用不同的请求\队列或者日志来参数划其他对象.命令模式也支持可撤销的操作

特点
* 易扩展
* 撤销操作
* 宏命令

要求将发出请求的对象和执行请求的对象解耦

## Chapter7 适配器模式
如果你身在欧洲,可能需要一个插头适配器来让你的设备能够在当地的插座上充电
### 适配器模式
适配器模式将一个类的接口,转换城客户期望的另一个接口.适配器让原本接口不兼容的类可以合作无间

* 对象适配器,对象适配器通过继承目标接口并组合适配者对象来进行适配
* 类适配器,类适配器使用多重继承完成适配


## Q
### 抽象类和接口的异同?
* 抽象类和接口都是上层抽象层,都不能被实例化,都能包含抽象方法
* 抽象类中可写非抽象方法,接口中只能有抽象方法
* Java中一个类只能继承一个父类,但可以实现多个接口

### abc.abstractmethod有啥用?写不写有啥影响?
声明为abstaractmethod的方法在子类中必须被继承,否则,子类无法实例化

